Class Hierarchy for RIG
-----------------------

RModuleManager		=> rig_mod_man
RModule				(name, loader pattern)
	RModLogin		=> rig_mod_login
	RModQuery		=> rig_mod_query
	RModAlbum		(generic album content)
		RModRigAlbum	(folder with only rig files)
		RModIzuDir		(folder with only izu files)
	RModPage
		RModRigImage
		RModIzuPage
		RModZipPage
	RModPageStat
	RModAccessLog
	RModCss			=> rig_mod_css
	RModCache		=> rig_mod_cache
	RModOptions		=> rig_mod_options
	RModStrings		=> rig_mod_str (provides i18n str:html_...)
	RModComments
	RModTemplate	=> rig_mod_template (aka the Template Manager)

RTemplate			(name, parent module etc.)

RMediaInfo			(query, web path, real path, cache path, option path)
	RMediaDir		(list/cache content)
	RMediaFile


Core Modules
------------

Some modules are part of a "core" suite. They are always loaded and thus
can always be accessed using a global variable.
	RModuleManager	=> rig_mod_man
	RModLogin		=> rig_mod_login
	RModQuery		=> rig_mod_query
	RModCss			=> rig_mod_css
	RModCache		=> rig_mod_cache
	RModOptions		=> rig_mod_options
	RModStrings		=> rig_mod_str
	RModTemplate	=> rig_mod_template

Ideally, all modules should be optional. Unfortunately that means
stupid redundant checks in the code to use a module only if present.
Overall the goal here is to be efficient, not just stupidly generic.
So we are going to assume these core modules are present, period.


Workflow
--------
- htdocs/index.php
	- htdocs/location.php
		=> defines location paths
	- htdocs/check_entry.php
- src/entry_point.php
	[old API] depending on the query string, call the right php script
	- upload	&  admin    -> admin_upload.php [N/A]
	- translate	&  admin    -> admin_translate.php [obsolete]
	- admin  	&  image    -> admin_image.php
	- admin  	& !image    -> admin_album.php
	- !admin 	&  image    -> image.php
	- !admin 	& !image    -> album.php
	- !admin    &  comment  -> comment.php [N/A]
	- !admin    &  overview -> overview.php [experimental]
	- !admin    &  tests    -> tests.php    [phpUnit testing]
	[new API]
	- construct the main RModuleManager object ($rig_mod_man)
	- load core modules
	- hook: init
	- using RModQuery
		- analyze query
		- hook: query
		- get query handler module
		- exec handler
	- hook: terminate


Modules Information
-------------------

Each module contains a description block which is stored in a PHP
comment at the beginning of the PHP code of the module.
To be loaded, a module must be a PHP file with a description block
stored in the rig/modules directory. PHP files that do not have a
description block are not analyzed and thus can contain anything.

The description block must have a signature "rig-module-1.0".
The block must begin somewhere in the first 50 lines of the file.
The number is arbitrary yet reasonable. It will avoid having to read
the whole file to get the block. The sooner the block is in the file,
the better as it reduces parsing.
Lines after the signature can be empty or contain a field or a comment.
Comments are lines starting with #.
Processing of fields stops at the first non-empty line that cannot
possibly be a field nor a comment (typically the closing */ comment).

The description block then contains a number of fields, one per line.
Fields are case-insensitive. White space is ignored as are blank lines.
When they can contain multiple values, they must be coma-separated.
A field is terminated by a line cariage (\n or \r or \r\n\).
Unknown fields are quietly ignored.
Fields may be preceded by whitespace (space or tabs).
The field name can only contain [a-zA-Z0-9-_]+.
Fields cannot be empty. A field with no value is not valid thus ignored.

The description block may contain the following fields:

Name:     The module name.
Desc:     A human-readable description of the module (one line).
Category: Core, All, MediaDir, MediaFile, Disabled
Depends:  A list of module names that must be present and loaded for 
		  this module to work. These modules will be loaded *before*
		  this module. Example:
		  RModTemplate,RModStrings
Query:    A regular expression that must match part of the query line.
		  Example:
		  /[?&]variable=value[&$]/

There is no version information in the description block.
In practice, if a module is incompatible with its previous versions,
simply give it a new name (f.ex. RModInfo, RModInfo2, etc.)

The module name should match the name of the main module class created
by this module. The file containing the module should be named
"<module-name>.php". Any class name valid in PHP is valid as a module name.
They need not match my personal convention "RModXxxYyyN".
If the name field exists, it is used to get the name of the module.
It is optional though. By default the filename (less the .php extension) is used.

Regexp for the description block:
	Signature:
		^[ \t]*rig-module-1.0[ \t]*$
	Fields:
		^[ \t]*([A-Za-z0-9-_]+):[ \t]*(.+)[ \t]*$
	Comments:
		^[ \t]*#

Modules will be loaded depending on the info in their description block.
For example the module manager could be requested to load all modules
that pertain to the category "All". If a module does not have a
Category field, it wouldn't be loaded. Same goes for the Query field.
Since a field with no value is ignored the line "Query:" is ignored
and is not equivalent to a query that would match anything (which
would be "Query: /.*/". Consequently modules with no query field would
not be examined when determining the handler for the current request.
This is of course good to create modules that must be loaded manually.

Note that the category "disabled" means this module can *never* be loaded
even by an explicit manual request.


Query State
-----------

RIG does not use session data.
Instead information is transmitted from request to request using
explicit query data. The purpose of such is that when following a link
it is enough to bookmark the URL to get the exact same page later.
The obvious inconvenience is that URLs tend to be long and verbose.

In the current monolithic architecture, the generation of the URL request
for a new link is generated by a single function that takes into account
the current context (image or album name, page number) and optional arguments
that override these values.

In the context of modules, this may be a bit harder to use. One centralized
function could not grow to handle any attribute of any unknown module...

Two possibilities: use RModQuery and "register"




---------------
*	$Log$
*	Revision 1.2  2004/12/25 09:46:46  ralfoide
*	Fixes and cleanup
*
*	Revision 1.1  2004/06/03 14:17:33  ralfoide
*	Experimenting with module classes
*	
---------------
